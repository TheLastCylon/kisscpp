Below, is the main.\-cpp for the kc\-\_\-echo application. It serves as a basic demonstratoin of the power we have available to us, through K\-I\-S\-S\-C\-P\-P.

It is a typical example of a main.\-cpp file, if you end up with a main.\-cpp file, that has more in it, you either have some very spicific requirements or you aren't using the library as intended.


\begin{DoxyCode}
\{(main.cpp)\}
#include \textcolor{stringliteral}{"kc\_echo.hpp"}

\textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char}* argv[])
\{
  \textcolor{keywordflow}{try} \{
    kc\_echo app;
    app.run();
  \} \textcolor{keywordflow}{catch} (std::exception& e) \{
    std::cerr << \textcolor{stringliteral}{"Exception: "} << e.what() << \textcolor{stringliteral}{"\(\backslash\)n"};
  \}

  \textcolor{keywordflow}{return} 0;
\}
\end{DoxyCode}


Examine the code above for a while, I hope it's clear that kc\-\_\-echo is a class name, and that it's being instantiated within the try block of our main function. Immideately after, the run method of that object is then executed.

Now consider the kc\-\_\-echo class\-:


\begin{DoxyCode}
\{(kc\_echo.hpp)\}
#ifndef \_KC\_ECHO\_HPP\_
#define \_KC\_ECHO\_HPP\_

#include <boost/thread.hpp>
#include <kisscpp/server.hpp>
#include <kisscpp/logstream.hpp>
#include \textcolor{stringliteral}{"handler\_echo.hpp"}

\textcolor{keyword}{class} kc\_echo : \textcolor{keyword}{public} \hyperlink{classkisscpp_1_1_server}{kisscpp::Server}      \textcolor{comment}{// Step 1: Derive
       your application's main class, from kisscpp::Server}
\{
  \textcolor{keyword}{public}:
    kc\_echo();
    ~kc\_echo();

  \textcolor{keyword}{protected}:
    \textcolor{keywordtype}{void} registerHandlers();                \textcolor{comment}{// This isn't stricly needed, I
       just like keep all my request-handler registreations in one place.}

  \textcolor{keyword}{private}:
    \hyperlink{namespacekisscpp_a21e40edcd4f1a3c7c1cc0015b576c8e5}{kisscpp::RequestHandlerPtr} echoHandler; \textcolor{comment}{// Step
       2: you need atleast one request Handler.}
\};

\textcolor{preprocessor}{#endif}
\end{DoxyCode}


That's it, that is all you need in order to have a basic server set up. Now consider the implimentation of that class\-:


\begin{DoxyCode}
\{(kc\_echo.cpp)\}
#include \textcolor{stringliteral}{"kc\_echo.hpp"}

kc\_echo::kc\_echo() : Server(\textcolor{stringliteral}{"localhost"}, \textcolor{stringliteral}{"9100"}, 1)
\{
  registerHandlers();
\}

kc\_echo::~kc\_echo()
\{
  stop();
\}

\textcolor{keywordtype}{void} kc\_echo::registerHandlers()
\{
  echoHandler.reset(\textcolor{keyword}{new} EchoHandler()); \textcolor{comment}{// Step 3. Instantiate your handler.}
  register\_handler(echoHandler);        \textcolor{comment}{// Step 4. Register your handler.}
\}
\end{DoxyCode}


That's it, all we need to do now, is implement the \char`\"{}echo\char`\"{} request handler. I follow a simple convention with handlers. I name the source files {\itshape handler\-\_\-} followed by the texctual id of the handler. i.\-e. With this example we'll have handler\-\_\-echo.\-cpp and handler\-\_\-echo.\-hpp. This serves to easily identify handlers from source file names.

Here is the Echo\-Handler class\-: 
\begin{DoxyCode}
\{(handler\_echo.hpp)\}
#ifndef \_HANDLER\_ECHO\_HPP\_
#define \_HANDLER\_ECHO\_HPP\_

#include <iostream>
#include <string>
#include <unistd.h>

#include <kisscpp/logstream.hpp>
#include <kisscpp/request\_handler.hpp>
#include <kisscpp/boost\_ptree.hpp>
#include <kisscpp/request\_status.hpp>

\textcolor{keyword}{class} EchoHandler : \textcolor{keyword}{public} \hyperlink{classkisscpp_1_1_request_handler}{kisscpp::RequestHandler}      
                           \textcolor{comment}{// Step 5. Derive your handler from kisscpp::RequestHandler}
\{
  \textcolor{keyword}{public}:
    EchoHandler() :
      kisscpp::RequestHandler(\textcolor{stringliteral}{"echo"}, \textcolor{stringliteral}{"Will echo back what you send in."}) \{\} \textcolor{comment}{//
       "echo" is the unique string that is used to identify your handler.}
                                                                             \textcolor{comment}{//
       i.e. requests to your application, that have "kcm-cmd" set to "echo"}
                                                                             \textcolor{comment}{//
       will cause this handler's run() method to be executed.}

    ~EchoHandler() \{\};

    \textcolor{keywordtype}{void} run(\textcolor{keyword}{const} \hyperlink{boost__ptree_8hpp_ab36820650b8e0db36402aea80485633c}{BoostPtree} &request, \hyperlink{boost__ptree_8hpp_ab36820650b8e0db36402aea80485633c}{BoostPtree} &
      response);               \textcolor{comment}{// Step 6. You must override the run method from
       kisscpp::RequestHandler}
  \textcolor{keyword}{protected}:
  \textcolor{keyword}{private}:
\};

\textcolor{preprocessor}{#endif}
\end{DoxyCode}


And now the last file you need for a complete kisscpp application.


\begin{DoxyCode}
\{(handler\_echo.cpp)\}
#include \textcolor{stringliteral}{"handler\_echo.hpp"}

\textcolor{keywordtype}{void} EchoHandler::run(\textcolor{keyword}{const} \hyperlink{boost__ptree_8hpp_ab36820650b8e0db36402aea80485633c}{BoostPtree} &request, \hyperlink{boost__ptree_8hpp_ab36820650b8e0db36402aea80485633c}{BoostPtree}
       &response)
\{
  \textcolor{keywordflow}{try} \{
    \textcolor{comment}{// This is where you build your response}
    response.put(\textcolor{stringliteral}{"kcm-sts"} , \hyperlink{namespacekisscpp_af5792fb0f68695c1a1e7a4c720d9262ea48f403b25d056ead863e1bb74664b388}{kisscpp::RQST\_SUCCESS});      
                \textcolor{comment}{// Make sure to set kcm-sts to RQST\_SUCCESS in the event of success}
    response.put(\textcolor{stringliteral}{"you-sent"}, request.get<std::string>(\textcolor{stringliteral}{"message"}));  \textcolor{comment}{// populate
       any aditional response parameters.}
  \} \textcolor{keywordflow}{catch} (boost::property\_tree::ptree\_bad\_path &e) \{
    response.put(\textcolor{stringliteral}{"kcm-sts"}, \hyperlink{namespacekisscpp_af5792fb0f68695c1a1e7a4c720d9262ea3ad7cafe8fc0329ea5edde0ebf5c807e}{kisscpp::RQST\_MISSING\_PARAMETER}
      );       \textcolor{comment}{// Make sure to set "kcm-sts" to the appropriate error status.}
    response.put(\textcolor{stringliteral}{"kcm-erm"}, e.what());
  \} \textcolor{keywordflow}{catch} (std::exception& e) \{
    response.put(\textcolor{stringliteral}{"kcm-sts"}, \hyperlink{namespacekisscpp_af5792fb0f68695c1a1e7a4c720d9262ea8b54c6e47b50ce90a375d79b957f5ddb}{kisscpp::RQST\_UNKNOWN});       
                   
    response.put(\textcolor{stringliteral}{"kcm-erm"}, e.what());
  \}
\}
\end{DoxyCode}


Remarkably, this is the part I consider the most difficult to understand. Yet it also happens to be the portion that has the least going on. 